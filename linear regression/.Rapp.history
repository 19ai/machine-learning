results <- kmeanspp( data.frame(iris_data) )
results$size
results <- kmeanspp( data.frame(iris_data) )#
#
results$size#
table( iris$Species, results$cluster )
kmeanspp <- function( data, k = 3, iter.max = 100 )#
{#
    sample_num <- nrow(data)    #
    center_ids <- sample.int( sample_num, 1 )#
#
    for( i in 1:( k-1 ) )#
    {       #
        dists <- apply( data[ center_ids[i], ], 1, function(center)#
        {#
            sqrt( rowSums( ( data - center )^2 ) )#
        })#
        if( i == 1 )#
        {#
            distance <- dists#
#
            # somehow distance between the same rows are not zero #
            # exclude the probability of the choosing the data point that are already chosen as centers#
            dists[center_ids] <- 0 #
            center_ids[ i+1 ] <- sample.int( sample_num, 1, prob = dists )#
#
        }else#
        {#
            distance <- cbind( distance, dists )#
            probs <- apply( distance, 1, min )          #
            probs[center_ids] <- 0#
            center_ids[ i+1 ] <- sample.int( sample_num, 1, prob = probs )#
        }                   #
    }#
#
    results <- kmeans( data, centers = data[ center_ids, ], iter.max = iter.max )#
    return(results) #
}#
#
results <- kmeanspp( data.frame(iris_data) )#
#
results$size#
table( iris$Species, results$cluster )
results <- kmeanspp( data.frame(iris_data) )#
#
results$size#
table( iris$Species, results$cluster )
library(gcookbook)
load("/Users/ethen/Downloads/tophitters2001.rda")
tophitters2001
dput(tophitters2001)
tophit <- tophitters2001[1:25, ]
dput(tophit)
ggplot(tophit, aes(x=avg, y=name)) + geom_point()
library(ggplot2)
ggplot(tophit, aes(x=avg, y=name)) + geom_point()
tophit <-  tophit[, c("name", "lg", "avg")]
tophit
dput(tophit)
library(ggplot2)#
#
# example dataset#
#
tophit <- structure(list(name = c("Larry Walker", "Ichiro Suzuki", "Jason Giambi", #
"Roberto Alomar", "Todd Helton", "Moises Alou", "Lance Berkman", #
"Bret Boone", "Frank Catalanotto", "Chipper Jones", "Albert Pujols", #
"Barry Bonds", "Sammy Sosa", "Juan Pierre", "Juan Gonzalez", #
"Luis Gonzalez", "Rich Aurilia", "Paul Lo Duca", "Jose Vidro", #
"Alex Rodriguez", "Cliff Floyd", "Shannon Stewart", "Jeff Cirillo", #
"Jeff Conine", "Derek Jeter"), lg = structure(c(2L, 1L, 1L, 1L, #
2L, 2L, 2L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 1L, 2L, 2L, 2L, 2L, 1L, #
2L, 1L, 2L, 1L, 1L), .Label = c("AL", "NL"), class = "factor"), #
    avg = c(0.3501, 0.3497, 0.3423, 0.3357, 0.3356, 0.3314, 0.331, #
    0.3307, 0.3305, 0.3304, 0.3288, 0.3277, 0.3276, 0.3274, 0.3252, #
    0.3251, 0.3239, 0.3196, 0.3189, 0.318, 0.3171, 0.3156, 0.3125, #
    0.3111, 0.3111)), .Names = c("name", "lg", "avg"), class = "data.frame", row.names = c(NA, #
25L))
tophit
ggplot( tophit, aes( reorder( name, avg ), avg ) ) + #
geom_point( size = 3 )
ggplot( tophit, aes( reorder( name, avg ), avg ) ) + #
geom_point( size = 3 ) + coord_flip()
ggplot( tophit, aes( reorder( name, avg ), avg ) ) + #
geom_point( size = 3 ) + coord_flip() +#
theme_bw()
ggplot( tophit, aes( reorder( name, avg ), avg ) ) + #
geom_point( size = 3 ) + coord_flip() +#
theme_bw( panel.grid.major.x = element_blank(),#
          panel.grid.major.y = element_blank()#
           )
ggplot( tophit, aes( reorder( name, avg ), avg ) ) + #
geom_point( size = 3 ) + coord_flip() +#
theme_bw() +#
theme( panel.grid.major.x = element_blank(),#
          panel.grid.major.y = element_blank()#
           )
ggplot( tophit, aes( reorder( name, avg ), avg ) ) + #
geom_point( size = 3 ) + coord_flip() +#
theme_bw()
tophit
order( tophit$lg, tophit$avg )
tophit$name[ order( tophit$lg, tophit$avg ) ]
name_order <- tophit$name[ order( tophit$lg, tophit$avg ) ]
sapply( tophit, class )
tophit$name <- factor( tophit$name, levels = name_order )
tophit
tophit$name
?gl
gl(2, 1, 20)
gl(2, 2, 20)
ggplot( tophit ) + #
geom_point( aes( name, avg, color = lg ) )
ggplot( tophit ) + #
geom_point( aes( name, avg, color = lg ) ) + #
coord_flip()
ggplot( tophit ) + #
geom_point( aes( name, avg, color = lg ) ) + #
coord_flip() + #
facet_wrap( lg ~ )
ggplot( tophit ) + #
geom_point( aes( name, avg, color = lg ) ) + #
coord_flip() + #
facet_wrap( lg ~. )
ggplot( tophit ) + #
geom_point( aes( name, avg, color = lg ) ) + #
facet_wrap( lg ~ )
ggplot( tophit, aes( name, avg, color = lg ) ) + #
geom_point(  ) + #
facet_wrap( lg ~ )
ggplot( tophit, aes( name, avg, color = lg ) ) + #
geom_point(  ) + #
facet_wrap( lg ~ . )
ggplot( tophit, aes( name, avg, color = lg ) ) + #
geom_point(  ) + #
facet_grid( lg ~ )
ggplot( tophit, aes( name, avg, color = lg ) ) + #
geom_point(  ) + #
facet_grid( lg ~ .)
ggplot( tophit, aes( name, avg, color = lg ) ) + #
geom_point(  ) + #
facet_grid(  ~ lg )
ggplot( tophit, aes( name, avg, color = lg ) ) + #
geom_point(  ) + #
facet_grid(  ~ lg ) + #
coord_flip()
ggplot( tophit, aes( name, avg, color = lg ) ) + #
geom_point(  ) + #
facet_grid( lg ~  ) + #
coord_flip()
ggplot( tophit, aes( name, avg, color = lg ) ) + #
geom_point(  ) + #
facet_grid( lg ~ . ) + #
coord_flip()
ggplot( tophit, aes( name, avg ) ) + #
geom_point( aes( color = lg ) ) + #
facet_grid( lg ~ . ) + #
coord_flip()
ggplot( tophit, aes( name, avg ) ) + #
geom_point( aes( color = lg ) ) + #
facet_grid( lg ~ . ) + #
coord_flip() +#
scale_colour_brewer(palette="Set1", limits=c("NL","AL"), guide=FALSE)
name_order <- tophit$name[ order( tophit$lg, tophit$avg ) ]#
# convert the name column to factor type column, and give the level by the name_order#
tophit$name <- factor( tophit$name, levels = name_order )
ggplot( tophit, aes( avg, name ) ) + #
geom_point( aes( color = lg ) ) + #
facet_grid( lg ~ . ) + #
# coord_flip() +#
scale_colour_brewer(palette="Set1", limits=c("NL","AL"), guide=FALSE)
ggplot(tophit, aes(x=avg, y=name)) +#
geom_segment(aes(yend=name), xend=0, colour="grey50") + geom_point(size=3, aes(colour=lg)) + scale_colour_brewer(palette="Set1", limits=c("NL","AL")) +#
theme_bw()
ggplot(tophit, aes(x=avg, y=name)) +#
#geom_segment(aes(yend=name), xend=0, colour="grey50") + #
geom_point(size=3, aes(colour=lg)) + #
scale_colour_brewer(palette="Set1", limits=c("NL","AL")) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
geom_point( aes( color = lg ) )
ggplot( tophit, aes( avg, name ) ) + #
geom_point( aes( color = lg ) ) + #
scale_colour_brewer(palette="Set1", labels=c("NL","AL"), guide=FALSE)
ggplot( tophit, aes( avg, name ) ) + #
geom_point( aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ), guide = FALSE )
ggplot( tophit, aes( avg, name ) ) + #
geom_point( aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_classic()
ggplot( tophit, aes( avg, name ) ) + #
geom_point( aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
geom_segment( aes( yend = name, xend = 0, color = "grey50" ) )#
geom_point( aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
# geom_segment( aes( yend = name, xend = 0, color = "grey50" ) )#
geom_point( aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
geom_segment( aes( yend = name ), xend = 0, color = "grey50" ) )#
geom_point( aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
geom_segment( aes( yend = name, xend = 0, color = "grey50" ) )#
geom_point( aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
geom_segment( aes( yend = name ), xend = 0, color = "grey50" )#
geom_point( aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
geom_segment( aes( yend = name ), xend = 0, color = "grey50" )#
geom_point( aes( color = lg ), size = 3 ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
geom_segment( aes( yend = name ), xend = 0, color = "grey50" )#
geom_point( aes( colour = lg ), size = 3 ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot(tophit, aes(x=avg, y=name)) +#
geom_segment(aes(yend=name), xend=0, colour="grey50") + #
geom_point(size=3, aes(colour=lg)) + #
scale_colour_brewer(palette="Set1", limits=c("NL","AL")) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
geom_segment( aes( yend = name ), xend = 0, color = "grey50" )#
geom_point( size = 3, aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( avg, name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" )#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, color = "grey50" )#
geom_point( size = 3, aes( color = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" )#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot(tophit, aes(x=avg, y=name)) +#
geom_segment(aes(yend=name), xend=0, colour="grey50") + #
geom_point(size=3, aes(colour=lg)) + #
scale_colour_brewer(palette="Set1", limits=c("NL","AL")) +#
theme_bw()
ggplot(tophit, aes( avg, name ) ) +#
geom_segment(aes(yend=name), xend=0, colour="grey50") + #
geom_point(size=3, aes(colour=lg)) + #
scale_colour_brewer(palette="Set1", limits=c("NL","AL")) +#
theme_bw()
ggplot(tophit, aes( avg, name ) ) +#
geom_segment(aes(yend=name), xend=0, colour="grey50") + #
geom_point(size=3, aes(colour=lg)) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot(tophit, aes( avg, name ) ) +#
geom_segment(aes(yend=name), xend=0, colour="grey50") + #
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot(tophit, aes( avg, name ) ) +#
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) + #
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot(tophit, aes( avg, name ) ) +#
geom_segment( aes( yend = name, xend = 0 ), colour = "grey50" ) + #
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot(tophit, aes( avg, name ) ) +#
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) + #
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot(tophit, aes( avg, name ) ) +#
geom_segment( aes( yend = name, xend = 0 ), colour = "grey50") + #
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot(tophit, aes( avg, name ) ) +#
geom_segment( aes( yend = name, xend = 0 ), colour = "grey50") + #
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw()
ggplot(tophit, aes( avg, name ) ) +#
geom_segment( aes( yend = name, xend = 0 ), colour = "grey50") + #
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw() +#
theme( panel.grid.major.y = element_blank(),#
       legend.position    = c( 1, 0.55 ) )
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw() +  #
facet_grid( lg ~ .)
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw() +  #
facet_grid( lg ~ ., space = "free_y" )
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ) ) +#
theme_bw() +  #
facet_grid( lg ~ ., scales = "free_y" )
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ), guide = FALSE ) +#
theme_bw() +  #
facet_grid( lg ~ ., scales = "free_y" )
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ), guide = FALSE ) +#
theme_bw() +  #
facet_grid( lg ~ ., scales = "free_y" ) + #
theme( panel.grid.major.y = element_blank() )
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ), guide = FALSE ) +#
theme_bw() +  #
facet_grid( lg ~ ., scales = "free_y" )
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ), guide = FALSE ) +#
theme_bw() +  #
facet_grid( lg ~ ., scales = "free_y" ) + #
theme( panel.grid.major.y = element_blank(), #
       panel.grid.major.x = element_blank() )
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ), guide = FALSE ) +#
theme_bw() +  #
facet_wrap( lg ~ ., scales = "free_y" ) + #
theme( panel.grid.major.y = element_blank(), #
       panel.grid.major.x = element_blank() )
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ), guide = FALSE ) +#
theme_bw() +  #
facet_wrap( lg ~ , scales = "free_y" ) + #
theme( panel.grid.major.y = element_blank(), #
       panel.grid.major.x = element_blank()
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ), guide = FALSE ) +#
theme_bw() +  #
facet_wrap(  ~ lg, scales = "free_y" ) + #
theme( panel.grid.major.y = element_blank(), #
       panel.grid.major.x = element_blank() )
ggplot( tophit, aes( x = avg, y = name ) ) + #
geom_segment( aes( yend = name ), xend = 0, colour = "grey50" ) +#
geom_point( size = 3, aes( colour = lg ) ) + #
scale_colour_brewer( palette = "Set1", limits = c( "NL", "AL" ), guide = FALSE ) +#
theme_bw() +  #
facet_grid( lg ~ ., scales = "free_y" ) + #
theme( panel.grid.major.y = element_blank(), #
       panel.grid.major.x = element_blank() )
library(sna)#
library(grid)#
library(ggnet)#
library(dplyr)#
library(scales) #
library(igraph)#
library(ggplot2)#
library(network)#
library(data.table)#
library(intergraph)#
library(RColorBrewer)
NetworkPlot <- function( news, layer = 4, grouping = "start" )#
{#
    # 1. reading in the edgelist dataset#
    # change the column order for new york times, combine the list for bbc #
    # also set the palette colors are the network plot #
    if( news == "NYtimes" )#
    {#
        filepath <- paste0( "/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_", layer, ".csv" )#
        edgelist <- data.table( read.csv(filepath) )#
        setcolorder( edgelist, c( "from", "to", "layer" ) )#
#
        palette <- "Set1"#
#
    }else # "BBC"#
    {#
        filepath <- paste0( "/Users/ethen/news-networks/bbc/bbc_data_new/edge_list_", layer, ".rds" )#
        edgelist <- readRDS(filepath)#
        edgelist <- data.table( do.call( rbind, edgelist ) )#
#
        palette <- "Set2"#
    }       #
#
    # 2. preprocessing #
    # exclude the layer column to remove duplicated edges or else ggnet won't work #
    unique_rows <- !duplicated( edgelist[ , -3, with = FALSE ] )#
    edgelist    <- edgelist[ unique_rows, ]#
    # remove the layer column and convert to igraph and network type    #
    graph_df <- graph.data.frame( edgelist[ , -3, with = FALSE ] )#
    network  <- asNetwork(graph_df)#
#
    # 3. grouping the nodes #
    # divide the nodes into two groups, top 10 news and others#
    # or by the starting nodes and others#
    if( grouping %in% c( "pagerank", "degree" ) )#
    {#
        top_10_news <- TopNews( graph_df, grouping )#
        boolean <- names( V(graph_df) ) %in% top_10_news$nodes  #
        network %v% "group" <- ifelse( boolean, "Top 10 News", "Others" )#
#
    }else # "start"#
    {#
        if( news == "NYtimes" )#
        {#
            starting_nodes <- read.csv("edge_list_1.csv")#
            boolean <- names( V(graph_df) ) %in% unique( starting_nodes$from )#
#
        }else # "BBC"#
        {#
            starting_nodes <- readRDS("edge_list_1.rds")#
            boolean <- names( V(graph_df) ) %in% unique( starting_nodes[[1]]$from )#
        }   #
        network %v% "group" <- ifelse( boolean, "Starting Nodes", "Others" )#
    }#
#
    # 4. visualization, plot uses randomized positioning as default, #
    # fix the positioning of the plot#
    # number of nodes and edges, goes with the title of the plot#
    edges <- length( E(graph_df) )#
    nodes <- length( V(graph_df) )#
    title <- paste0( "# of nodes:", nodes, "; ", "# of edges:", edges )#
#
    set.seed(1234)#
    network_plot <- ggnet2( network, #
        node.size  = 6, #
        alpha      = .6,#
        node.color = "group",#
        palette    = palette,#
        edge.alpha = .9,#
        arrow.type = "open",#
        arrow.size = 5,#
        #arrow.gap = .18,#
        edge.label = edgelist$layer,#
        edge.label.size = 3,        #
        edge.color = c("color", "grey") #
    ) + ggtitle( paste0( "Structure of ", news, "\n", title ) )#
#
    return(network_plot)#
}
network_plot <- NetworkPlot("NYtimes")
library(sna)#
library(grid)#
library(ggnet)#
library(dplyr)#
library(scales) #
library(igraph)#
library(ggplot2)#
library(network)#
library(data.table)#
library(intergraph)#
library(RColorBrewer)
NetworkPlot <- function( news, layer = 4, grouping = "start" )#
{#
    # 1. reading in the edgelist dataset#
    # change the column order for new york times, combine the list for bbc #
    # also set the palette colors are the network plot #
    if( news == "NYtimes" )#
    {#
        filepath <- paste0( "/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_", layer, ".csv" )#
        edgelist <- data.table( read.csv(filepath) )#
        setcolorder( edgelist, c( "from", "to", "layer" ) )#
#
        palette <- "Set1"#
#
    }else # "BBC"#
    {#
        filepath <- paste0( "/Users/ethen/news-networks/bbc/bbc_data_new/edge_list_", layer, ".rds" )#
        edgelist <- readRDS(filepath)#
        edgelist <- data.table( do.call( rbind, edgelist ) )#
#
        palette <- "Set2"#
    }       #
#
    # 2. preprocessing #
    # exclude the layer column to remove duplicated edges or else ggnet won't work #
    unique_rows <- !duplicated( edgelist[ , -3, with = FALSE ] )#
    edgelist    <- edgelist[ unique_rows, ]#
    # remove the layer column and convert to igraph and network type    #
    graph_df <- graph.data.frame( edgelist[ , -3, with = FALSE ] )#
    network  <- asNetwork(graph_df)#
#
    # 3. grouping the nodes #
    # divide the nodes into two groups, top 10 news and others#
    # or by the starting nodes and others#
    if( grouping %in% c( "pagerank", "degree" ) )#
    {#
        top_10_news <- TopNews( graph_df, grouping )#
        boolean <- names( V(graph_df) ) %in% top_10_news$nodes  #
        network %v% "group" <- ifelse( boolean, "Top 10 News", "Others" )#
#
    }else # "start"#
    {#
        if( news == "NYtimes" )#
        {#
            starting_nodes <- read.csv("/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_1.csv")#
            boolean <- names( V(graph_df) ) %in% unique( starting_nodes$from )#
#
        }else # "BBC"#
        {#
            starting_nodes <- readRDS("/Users/ethen/news-networks/bbc/bbc_data_new/edge_list_1.rds")#
            boolean <- names( V(graph_df) ) %in% unique( starting_nodes[[1]]$from )#
        }   #
        network %v% "group" <- ifelse( boolean, "Starting Nodes", "Others" )#
    }#
#
    # 4. visualization, plot uses randomized positioning as default, #
    # fix the positioning of the plot#
    # number of nodes and edges, goes with the title of the plot#
    edges <- length( E(graph_df) )#
    nodes <- length( V(graph_df) )#
    title <- paste0( "# of nodes:", nodes, "; ", "# of edges:", edges )#
#
    set.seed(1234)#
    network_plot <- ggnet2( network, #
        node.size  = 6, #
        alpha      = .6,#
        node.color = "group",#
        palette    = palette,#
        edge.alpha = .9,#
        arrow.type = "open",#
        arrow.size = 5,#
        #arrow.gap = .18,#
        edge.label = edgelist$layer,#
        edge.label.size = 3,        #
        edge.color = c("color", "grey") #
    ) + ggtitle( paste0( "Structure of ", news, "\n", title ) )#
#
    return(network_plot)#
}
network_plot <- NetworkPlot("NYtimes")
TopNews <- function( graph_dataframe, grouping = "pagerank" )#
{#
    if( grouping == "pagerank" )#
    {#
        attribute_data <- data.table( nodes = names( V(graph_dataframe) ), #
                                      score = page.rank( graph_dataframe )$vector ) %>%#
                          arrange( desc(score) )            #
    }#
#
    if( grouping == "degree" )#
    {#
        # uses degree to represent the top 10 news #
        attribute_data <- data.table( nodes = names( V(graph_dataframe) ), #
                                      score = igraph::degree(graph_dataframe) ) %>%#
                          arrange( desc(score) )#
    }#
#
    # extract the news with the top 10 score, via pagerank or degree#
    top_10_news <- top_n( attribute_data, 10, score )#
    return(top_10_news)#
}
NetworkPlot <- function( news, layer = 4, grouping = "start" )#
{#
    # 1. reading in the edgelist dataset#
    # change the column order for new york times, combine the list for bbc #
    # also set the palette colors are the network plot #
    if( news == "NYtimes" )#
    {#
        filepath <- paste0( "/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_", layer, ".csv" )#
        edgelist <- data.table( read.csv(filepath) )#
        setcolorder( edgelist, c( "from", "to", "layer" ) )#
#
        palette <- "Set1"#
#
    }else # "BBC"#
    {#
        filepath <- paste0( "/Users/ethen/news-networks/bbc/bbc_data_new/edge_list_", layer, ".rds" )#
        edgelist <- readRDS(filepath)#
        edgelist <- data.table( do.call( rbind, edgelist ) )#
#
        palette <- "Set2"#
    }       #
#
    # 2. preprocessing #
    # exclude the layer column to remove duplicated edges or else ggnet won't work #
    unique_rows <- !duplicated( edgelist[ , -3, with = FALSE ] )#
    edgelist    <- edgelist[ unique_rows, ]#
    # remove the layer column and convert to igraph and network type    #
    graph_df <- graph.data.frame( edgelist[ , -3, with = FALSE ] )#
    network  <- asNetwork(graph_df)#
#
    # 3. grouping the nodes #
    # divide the nodes into two groups, top 10 news and others#
    # or by the starting nodes and others#
    if( grouping %in% c( "pagerank", "degree" ) )#
    {#
        top_10_news <- TopNews( graph_df, grouping )#
        boolean <- names( V(graph_df) ) %in% top_10_news$nodes  #
        network %v% "group" <- ifelse( boolean, "Top 10 News", "Others" )#
#
    }else # "start"#
    {#
        if( news == "NYtimes" )#
        {#
            starting_nodes <- read.csv("/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_1.csv")#
            boolean <- names( V(graph_df) ) %in% unique( starting_nodes$from )#
#
        }else # "BBC"#
        {#
            starting_nodes <- readRDS("/Users/ethen/news-networks/bbc/bbc_data_new/edge_list_1.rds")#
            boolean <- names( V(graph_df) ) %in% unique( starting_nodes[[1]]$from )#
        }   #
        network %v% "group" <- ifelse( boolean, "Starting Nodes", "Others" )#
    }#
#
    # 4. visualization, plot uses randomized positioning as default, #
    # fix the positioning of the plot#
    # number of nodes and edges, goes with the title of the plot#
    edges <- length( E(graph_df) )#
    nodes <- length( V(graph_df) )#
    title <- paste0( "# of nodes:", nodes, "; ", "# of edges:", edges )#
#
    set.seed(1234)#
    network_plot <- ggnet2( network, #
        node.size  = 6, #
        alpha      = .6,#
        node.color = "group",#
        palette    = palette,#
        edge.alpha = .9,#
        arrow.type = "open",#
        arrow.size = 5,#
        #arrow.gap = .18,#
        edge.label = edgelist$layer,#
        edge.label.size = 3,        #
        edge.color = c("color", "grey") #
    ) + ggtitle( paste0( "Structure of ", news, "\n", title ) )#
#
    return(network_plot)#
}
network_plot <- NetworkPlot("NYtimes")
news= "NYtimes"
layer = 4
grouping = "start"
filepath <- paste0( "/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_", layer, ".csv" )#
        edgelist <- data.table( read.csv(filepath) )#
        setcolorder( edgelist, c( "from", "to", "layer" ) )#
#
        palette <- "Set1"
edgelist
unique_rows <- !duplicated( edgelist[ , -3, with = FALSE ] )#
    edgelist    <- edgelist[ unique_rows, ]#
    # remove the layer column and convert to igraph and network type    #
    graph_df <- graph.data.frame( edgelist[ , -3, with = FALSE ] )#
    network  <- asNetwork(graph_df)
starting_nodes <- read.csv("/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_1.csv")#
            boolean <- names( V(graph_df) ) %in% unique( starting_nodes$from )
network %v% "group" <- ifelse( boolean, "Starting Nodes", "Others" )
edges <- length( E(graph_df) )#
    nodes <- length( V(graph_df) )#
    title <- paste0( "# of nodes:", nodes, "; ", "# of edges:", edges )#
#
    set.seed(1234)#
    network_plot <- ggnet2( network, #
        node.size  = 6, #
        alpha      = .6,#
        node.color = "group",#
        palette    = palette,#
        edge.alpha = .9,#
        arrow.type = "open",#
        arrow.size = 5,#
        #arrow.gap = .18,#
        edge.label = edgelist$layer,#
        edge.label.size = 3,        #
        edge.color = c("color", "grey") #
    ) + ggtitle( paste0( "Structure of ", news, "\n", title ) )
edges <- length( E(graph_df) )#
    nodes <- length( V(graph_df) )#
    title <- paste0( "# of nodes:", nodes, "; ", "# of edges:", edges )
network %v% "group"
ggnet2(network)
edgelist$layer
summary(edgelist)
filepath <- paste0( "/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_", layer, ".csv" )#
        edgelist <- data.table( read.csv(filepath) )#
        setcolorder( edgelist, c( "from", "to", "layer" ) )#
#
        palette <- "Set1"
unique_rows <- !duplicated( edgelist[ , -3, with = FALSE ] )#
    edgelist    <- edgelist[ unique_rows & complete.cases(edgelist), ]
summary(edgelist)
library(sna)#
library(grid)#
library(ggnet)#
library(dplyr)#
library(scales) #
library(igraph)#
library(ggplot2)#
library(network)#
library(data.table)#
library(intergraph)#
library(RColorBrewer)
TopNews <- function( graph_dataframe, grouping = "pagerank" )#
{#
    if( grouping == "pagerank" )#
    {#
        attribute_data <- data.table( nodes = names( V(graph_dataframe) ), #
                                      score = page.rank( graph_dataframe )$vector ) %>%#
                          arrange( desc(score) )            #
    }#
#
    if( grouping == "degree" )#
    {#
        # uses degree to represent the top 10 news #
        attribute_data <- data.table( nodes = names( V(graph_dataframe) ), #
                                      score = igraph::degree(graph_dataframe) ) %>%#
                          arrange( desc(score) )#
    }#
#
    # extract the news with the top 10 score, via pagerank or degree#
    top_10_news <- top_n( attribute_data, 10, score )#
    return(top_10_news)#
}
NetworkPlot <- function( news, layer = 4, grouping = "start" )#
{#
    # 1. reading in the edgelist dataset#
    # change the column order for new york times, combine the list for bbc #
    # also set the palette colors are the network plot #
    if( news == "NYtimes" )#
    {#
        filepath <- paste0( "/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_", layer, ".csv" )#
        edgelist <- data.table( read.csv(filepath) )#
        setcolorder( edgelist, c( "from", "to", "layer" ) )#
#
        palette <- "Set1"#
#
    }else # "BBC"#
    {#
        filepath <- paste0( "/Users/ethen/news-networks/bbc/bbc_data_new/edge_list_", layer, ".rds" )#
        edgelist <- readRDS(filepath)#
        edgelist <- data.table( do.call( rbind, edgelist ) )#
#
        palette <- "Set2"#
    }       #
#
    # 2. preprocessing #
    # exclude the layer column to remove duplicated edges or else ggnet won't work #
    unique_rows <- !duplicated( edgelist[ , -3, with = FALSE ] )#
    edgelist    <- edgelist[ unique_rows & complete.cases(edgelist), ]#
    # remove the layer column and convert to igraph and network type    #
    graph_df <- graph.data.frame( edgelist[ , -3, with = FALSE ] )#
    network  <- asNetwork(graph_df)#
#
    # 3. grouping the nodes #
    # divide the nodes into two groups, top 10 news and others#
    # or by the starting nodes and others#
    if( grouping %in% c( "pagerank", "degree" ) )#
    {#
        top_10_news <- TopNews( graph_df, grouping )#
        boolean <- names( V(graph_df) ) %in% top_10_news$nodes  #
        network %v% "group" <- ifelse( boolean, "Top 10 News", "Others" )#
#
    }else # "start"#
    {#
        if( news == "NYtimes" )#
        {#
            starting_nodes <- read.csv("/Users/ethen/news-networks/NYtimes/NYtimes_data_new/edge_list_1.csv")#
            boolean <- names( V(graph_df) ) %in% unique( starting_nodes$from )#
#
        }else # "BBC"#
        {#
            starting_nodes <- readRDS("/Users/ethen/news-networks/bbc/bbc_data_new/edge_list_1.rds")#
            boolean <- names( V(graph_df) ) %in% unique( starting_nodes[[1]]$from )#
        }   #
        network %v% "group" <- ifelse( boolean, "Starting Nodes", "Others" )#
    }#
#
    # 4. visualization, plot uses randomized positioning as default, #
    # fix the positioning of the plot#
    # number of nodes and edges, goes with the title of the plot#
    edges <- length( E(graph_df) )#
    nodes <- length( V(graph_df) )#
    title <- paste0( "# of nodes:", nodes, "; ", "# of edges:", edges )#
#
    set.seed(1234)#
    network_plot <- ggnet2( network, #
        node.size  = 6, #
        alpha      = .6,#
        node.color = "group",#
        palette    = palette,#
        edge.alpha = .9,#
        arrow.type = "open",#
        arrow.size = 5,#
        #arrow.gap = .18,#
        edge.label = edgelist$layer,#
        edge.label.size = 3,        #
        edge.color = c("color", "grey") #
    ) + ggtitle( paste0( "Structure of ", news, "\n", title ) )#
#
    return(network_plot)#
}
network_plot <- NetworkPlot("NYtimes")
network_plot
library(ggplot2)#
#
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = function(x) 1.2 * (x-2)^2 + 3.2 )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = function(x) 1.2 * (x-2)^2 + 3.2 ) + #
geom_text( data = data.frame( x = 2 ) )
Formula <- function(x) 1.2 * (x-2)^2 + 3.2
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ) )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), color = "blue" )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3 )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) )
Derivative <- function(x) 2 * 1.2 * (x-2)
x <- .1
learning_rate <- .6
for( step in 1:10 )#
{#
    x <- x - learning_rate * Derivative(x)#
    print(x)#
}
for( step in 1:10 )#
{#
    x <- x - learning_rate * Derivative(x)#
    print(x)#
    print( Formula(x) )#
}
x <- .1
for( step in 1:10 )#
{#
    x <- x - learning_rate * Derivative(x)#
    print(x)#
    print( Formula(x) )#
}
library(ggplot2)#
#
# original formula #
Formula <- function(x) 1.2 * (x-2)^2 + 3.2#
#
# first derivative of the formula#
Derivative <- function(x) 2 * 1.2 * (x-2) #
#
# visualize the function, and the optimal solution#
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) )
x_new <- .1 #
x_old <- 0#
# manually assign a fix learning rate #
learning_rate <- .6#
# other paramaters #
epsilon <- .001#
step <- 1#
iteration <- 10#
#
# records the x and y value for visualization #
xtrace <- list() ; ytrace <- list()#
while( abs( x_new - x_old ) > epsilon | step <= iteration )#
{#
    step <- step + 1#
#
    x_old <- x_new#
    x_new <- x_old - learning_rate * Derivative(x)#
    xtrace[[step]] <- x_new#
    ytrace[[step]] <- Formula(x_new)#
}
x_new <- .1 #
x_old <- 0#
# manually assign a fix learning rate #
learning_rate <- .6#
# other paramaters #
epsilon <- .001#
step <- 1#
iteration <- 10#
#
# records the x and y value for visualization #
xtrace <- list() ; ytrace <- list()
while( abs( x_new - x_old ) > epsilon | step <= iteration )#
{#
    step <- step + 1#
#
    x_old <- x_new#
    x_new <- x_old - learning_rate * Derivative(x_old)#
    xtrace[[step]] <- x_new#
    ytrace[[step]] <- Formula(x_new)#
}
xtrace
x_new <- .1 #
x_old <- 0#
# manually assign a fix learning rate #
learning_rate <- .6#
# other paramaters #
epsilon <- .001#
step <- 1#
iteration <- 10#
#
# records the x and y value for visualization #
xtrace <- list() ; ytrace <- list()
while( abs( x_new - x_old ) > epsilon & step <= iteration )#
{   #
    # gradient descent#
    x_old <- x_new#
    x_new <- x_old - learning_rate * Derivative(x_old)#
    # record keeping #
    xtrace[[step]] <- x_new#
    ytrace[[step]] <- Formula(x_new)#
#
    # update iteration count #
    step <- step + 1#
}
xtrace
ytrace
x_new <- .1 #
x_old <- 0#
# manually assign a fix learning rate #
learning_rate <- .6#
# other paramaters #
epsilon <- .01#
step <- 1#
iteration <- 10#
#
# records the x and y value for visualization #
xtrace <- list() ; ytrace <- list()#
while( abs( x_new - x_old ) > epsilon & step <= iteration )#
{   #
    # gradient descent#
    x_old <- x_new#
    x_new <- x_old - learning_rate * Derivative(x_old)#
    # record keeping #
    xtrace[[step]] <- x_new#
    ytrace[[step]] <- Formula(x_new)#
#
    # update iteration count #
    step <- step + 1#
}
xtrace
record <- data.frame( x = do.call( rbind, xtrace ), y = do.call( rbind, ytrace ) )
record
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange" )
x_new <- .1 #
x_old <- 0#
# manually assign a fix learning rate #
learning_rate <- .6#
# other paramaters : manually assign epilson value, maximum iteration allowed #
epsilon <- .1#
step <- 1#
iteration <- 10#
#
# records the x and y value for visualization ; add the inital guess #
xtrace <- list() ; ytrace <- list()#
xtrace[[1]] <- x_new ; xtrace[[1]] <- Formula(x_new)
xtrace
x_new <- .1 #
x_old <- 0#
# manually assign a fix learning rate #
learning_rate <- .6#
# other paramaters : manually assign epilson value, maximum iteration allowed #
epsilon <- .1#
step <- 1#
iteration <- 10#
#
# records the x and y value for visualization ; add the inital guess #
xtrace <- list() ; ytrace <- list()#
xtrace[[1]] <- x_new ; ytrace[[1]] <- Formula(x_new)
xtrace
while( abs( x_new - x_old ) > epsilon & step <= iteration )#
{#
    # update iteration count #
    step <- step + 1    #
    # gradient descent#
    x_old <- x_new#
    x_new <- x_old - learning_rate * Derivative(x_old)#
    # record keeping #
    xtrace[[step]] <- x_new#
    ytrace[[step]] <- Formula(x_new)    #
}#
#
record <- data.frame( x = do.call( rbind, xtrace ), y = do.call( rbind, ytrace ) )
record
xtrace
x_new <- .1 #
x_old <- 0#
# manually assign a fix learning rate #
learning_rate <- .6#
# other paramaters : manually assign epilson value, maximum iteration allowed #
epsilon <- .01#
step <- 1#
iteration <- 10#
#
# records the x and y value for visualization ; add the inital guess #
xtrace <- list() ; ytrace <- list()#
xtrace[[1]] <- x_new ; ytrace[[1]] <- Formula(x_new)#
#
while( abs( x_new - x_old ) > epsilon & step <= iteration )#
{#
    # update iteration count #
    step <- step + 1    #
    # gradient descent#
    x_old <- x_new#
    x_new <- x_old - learning_rate * Derivative(x_old)#
    # record keeping #
    xtrace[[step]] <- x_new#
    ytrace[[step]] <- Formula(x_new)    #
}#
#
record <- data.frame( x = do.call( rbind, xtrace ), y = do.call( rbind, ytrace ) )
record
x_new <- .1 #
x_old <- 0#
# manually assign a fix learning rate #
learning_rate <- .6#
# other paramaters : manually assign epilson value, maximum iteration allowed #
epsilon <- .05#
step <- 1#
iteration <- 10#
#
# records the x and y value for visualization ; add the inital guess #
xtrace <- list() ; ytrace <- list()#
xtrace[[1]] <- x_new ; ytrace[[1]] <- Formula(x_new)#
#
while( abs( x_new - x_old ) > epsilon & step <= iteration )#
{#
    # update iteration count #
    step <- step + 1    #
    # gradient descent#
    x_old <- x_new#
    x_new <- x_old - learning_rate * Derivative(x_old)#
    # record keeping #
    xtrace[[step]] <- x_new#
    ytrace[[step]] <- Formula(x_new)    #
}#
#
record <- data.frame( x = do.call( rbind, xtrace ), y = do.call( rbind, ytrace ) )
record
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", alpha = .5 )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 2, alpha = .5 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3 )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3 )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3, alpha = .8 )
library(ggplot2)#
#
# original formula #
Formula <- function(x) 1.2 * (x-2)^2 + 3.2#
#
# first derivative of the formula#
Derivative <- function(x) 2 * 1.2 * (x-2) #
#
# visualize the function, and the optimal solution#
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) )
x_new <- .1 #
x_old <- 0#
# manually assign a fix learning rate #
learning_rate <- .6#
# other paramaters : manually assign epilson value, maximum iteration allowed #
epsilon <- .05#
step <- 1#
iteration <- 10#
#
# records the x and y value for visualization ; add the inital guess #
xtrace <- list() ; ytrace <- list()#
xtrace[[1]] <- x_new ; ytrace[[1]] <- Formula(x_new)#
#
while( abs( x_new - x_old ) > epsilon & step <= iteration )#
{#
    # update iteration count #
    step <- step + 1    #
    # gradient descent#
    x_old <- x_new#
    x_new <- x_old - learning_rate * Derivative(x_old)#
    # record keeping #
    xtrace[[step]] <- x_new#
    ytrace[[step]] <- Formula(x_new)    #
}#
#
record <- data.frame( x = do.call( rbind, xtrace ), y = do.call( rbind, ytrace ) )#
#
# visualize the gradient descent's value #
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3, alpha = .8, shape = 2 )
record
record[ 1, ]
record[ 2, ]
rbind( record[ 1, ], record[ 2, ] )
cbind( record[ 1, ], record[ 2, ] )
segment <- data.frame()#
segment <- cbind( record[ 1, ], record[ 2, ] )
segment
segment$x
names(segment)
xtrace
cbind( xtrace, ytrace )
class(cbind( xtrace, ytrace ))
segment <- data.frame()#
for( i in 1:( nrow(record)-1 ) )#
{#
    segment[i,] <- cbind( record[ i, ], record[ i+1, ] )    #
}
row(record)-1
nrow(record)-1
segment <- data.frame()
for( i in 1:( nrow(record)-1 ) )#
{#
    segment[i,] <- cbind( record[ i, ], record[ i+1, ] )    #
}
segment <- data.frame( x = double(), y = double(), xend = double(), yend = double() )#
for( i in 1:( nrow(record)-1 ) )#
{#
    segment[i,] <- cbind( record[ i, ], record[ i+1, ] )    #
}
record
segment
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3, alpha = .8, shape = 2 ) +#
geom_segment( data = segment , aes( x = x, y = y, xend = xend, yend = yend ) )
?geom_segment
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3, alpha = .8, shape = 2 ) +#
geom_segment( data = segment , aes( x = x, y = y, xend = xend, yend = yend ), #
              color = "oragne", arrow = arrow() )
?arrow
library(grid)
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3, alpha = .8, shape = 2 ) +#
geom_segment( data = segment , aes( x = x, y = y, xend = xend, yend = yend ), #
              color = "oragne", arrow = arrow() )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3, alpha = .8, shape = 2 ) +#
geom_segment( data = segment , aes( x = x, y = y, xend = xend, yend = yend ), #
              color = "orange", arrow = arrow() )
?arrow
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3, alpha = .8, shape = 2 ) +#
geom_segment( data = segment , aes( x = x, y = y, xend = xend, yend = yend ), #
              color = "orange", arrow = arrow( length = unit( 0.25, "inches" ) ) )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3, alpha = .8, shape = 2 ) +#
geom_segment( data = segment , aes( x = x, y = y, xend = xend, yend = yend ), #
              color = "orange", arrow = arrow( length = unit( 0.25, "cm" ) ) )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
geom_point( data = data.frame( x = 2, y = Formula(2) ), aes( x, y ), #
            color = "blue", size = 3, alpha = .8 ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "orange", size = 3, alpha = .8, shape = 2 ) +#
geom_segment( data = segment , aes( x = x, y = y, xend = xend, yend = yend ), #
              color = "orange", alpha = .8, arrow = arrow( length = unit( 0.25, "cm" ) ) )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "blue", size = 3, alpha = .8, shape = 2 ) +#
geom_segment( data = segment , aes( x = x, y = y, xend = xend, yend = yend ), #
              color = "lightblue", alpha = .8, arrow = arrow( length = unit( 0.25, "cm" ) ) )
ggplot( data.frame( x = c( 0, 4 ) ), aes( x ) ) + #
stat_function( fun = Formula ) + #
ggtitle( expression( 1.2 * (x-2)^2 + 3.2 ) ) + #
geom_point( data = record, aes( x, y ), color = "red", size = 3, alpha = .8, shape = 2 ) +#
geom_segment( data = segment , aes( x = x, y = y, xend = xend, yend = yend ), #
              color = "blue", alpha = .8, arrow = arrow( length = unit( 0.25, "cm" ) ) )
x0 <- c(1,1,1,1,1) # column of 1's#
x1 <- c(1,2,3,4,5) # original x-values#
y  <- c(3,7,5,11,14)#
# create the x- matrix of explanatory variables#
data <- data.frame( x0 = x0, x1 = x1, y = y )
data
library(dplyr)
data %>% select_( ~ x0 + x1 )
data %>% select_( ~ x0  )
?select_
?select
data %>% select_( x1 ~ x0  )
data %>% select_( x1 + x0 ~   )
data %>% select_(  ~ x1 + x0  )
data %>% select_( .dots =  ~ x1 + x0  )
data %>% select_( .dots =  ~ x0 + x1   )
library(lazyeval)
function_call2 <- interp( ~ x + y, x = as.name(x0), y = as.name(x1) )
data %>% select_( .dots =  function_call2   )
function_call2
function_call2 <- interp( ~ x + y, x = as.name("x0"), y = as.name("x1") )
function_call2
as.name("x0")
data %>% select_( .dots =  function_call2   )
names(data)
data %>% select_( ~ y   )
data %>% select_( ~ y +x   )
data %>% select_( ~ y +x0   )
data %>% select_( ~ x0 +y  )
data
?interp
names(mtcars)
mtcars %>% select_( ~ mpg + cyl )
?select_
vignette("nse")
mtcars %>% select_( ~ list(mpg + cyl) )
mtcars %>% select_( .dots =  list(~x0, ~x1) )
data %>% select_( .dots =  list(~x0, ~x1) )
data %>% select( x0, x1 )
data %>% select_( ~ -y  )
data %>% select( -y )
quote(x0)
as.name("xo")
feature = y
feature
data %>% select( -feature )
GradientDescent <- function( target = y, data = data )#
{#
    data <- data %>% select( -feature )#
    return(data)#
}#
GradientDescent( y, data )
?magittr
GradientDescent <- function( target = y, data = data )#
{#
    features <- data %>% select( -target )#
    return(features)#
}#
GradientDescent( y, data )
setwd("/Users/ethen/machine-learning/linear regression")#
housing <- read.csv("housing.csv")
housing
